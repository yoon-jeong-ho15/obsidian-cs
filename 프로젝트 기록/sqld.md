# 개념
## 데이터 모델링의 이해
2,3,3,2,3 / 2,4,4,2,3 / 1,1,1,2,3 / 2,1,4,3,4 / 2,2,2,3,4 / 4,4,2,2,3/ 3,2,1,3,2 / 3,4,4,3,3 / 1,2,2,1,1 / 3,1,2,1,4

속성 : 
- 기본 속성 : 엔터티가 본래부터 가지고 있어야 하는 속성.
- 설계 속성 : 시스템 설계시에 필요하다고 판단되어 도출된 속성.
- 파생 속성 :  다른 속성으로부터 계산되거나 특정 규칙에 따라 변형되어 만들어진 속성.

도메인 :
- 속성이 가질 수 있는 값의 범위
	- 예시) 다섯자리 숫자, 1 부터 100 까지의 숫자 등

엔터티의 유형 (발생 시점에 따른 분류): 
- 기본 엔터티
- 중심 엔터티
- 행위 엔터티

순수 관계 연산자 :
- select
- project
- join
- divide

배치(batch) 작업 : 

self-join : 
running total을 구할때 사용



# 문제
11번
- 테이블에 `''`을 입력하면 null이 입력된다
- `varchar2`자료형임에도 모두 숫자인경우 `where col1 = 1`처럼 숫자로 질의를 해도 오류가 나지 않는다.

12번
- LTRIM RTRIM 모두공백을 포함하지 않음

13번
- `to_date('201501', 'YYYYMM')`은 2015년 01월 01일 00시 00분이 된다.

14번
- group by 절에서는 select 절과 같이 alias 명을 사용할 수 없다.
- 집계 함수는 null 값을 제외하여 수행한다.

17번
- `case when loc = 'New York' then 'east' else 'etc' end`
- `case loc when 'New York' then 'east' else 'etc' end`
- `decode(loc, 'New York', 'east', 'etc')`
- 위는 모두 같은 결과를 출력한다.

18번
- sql server에서 `isnull`은 오라클의 `nvl`과 같은 함수

20번
- `Nullif()`함수는 컬럼의 값이 어떤것과 같으면 null로 표기한다

22번
- `_`는 글자수를 지정

28번
- `order by (case when id = '999' then 0 else id end)`
- 여기서 0은 순서가 된다.

29번
- 원래는 select절에 없는 컬럼을 가지고 order by를 할 수 없지만, oracle은 가능하다.(행기반 데이터베이스여서)
- 그러나 group by 절을 사용한다면 반드시 group by 절에 포함된 컬럼만 사용 가능하다.

35번
- dbms 옵티마이저는 조인을 2개의 테이블씩 처리한다.
- 일반적으로 조인은 pk와 fk의 값의 연관성에 의해 성립
- equi join 은 테이블 간의 칼럼 값들이 정확하게 일치하는 경우에 사용되는 방법, '=' 연산자에 의해서만 수행된다
- >, <, >=, <= 과 같은 부등식은 non equi join

37번
- 순수 관계 연산자

*38번*
- 1번이 오답인 이유 : where의 연관 서브 쿼리 결과를 예측해보면 고객id가 001에 해당하는 모든 컨텐츠id가 출력된다. 그래서 하나라도 비선호컨텐츠를 추가한 회원은 언제나 결과가 t가 되기 때문에 어떤 추천도 받지 못한다.
- 2번이 오답인 이유 :
	- 일단 비선호컨텐츠에 있는 컨텐츠id를 거르려면 `and d.컨텐츠id is null`이어야 한다.

*41번*
- 1번이 오답인 이유 : `B.사용시간대 <= C.시작시간대 and B.사용시간대 >= C.시작시간대`는 B 사용시간대가 C의 구간을 완전히 포함해야한다.
- 2번이 오답인 이유 : `from 고객 A inner join 시간대별사용량 B inner join 시간대구간 C` 과 같은 문법은 없다.

*44번*
- 2번이 아닌 이유 : `left outer join 단말기 B on (A.고객번호 in (11000,12000) and A.단말기id = B.단말기id)` 
	- left outer join이기 때문에 행 수는 고객 테이블과 일치하는게 맞다.
	- 그리고 join on 안에 조건이 적혀있기 때문에 join 이전에 적용되기 때문에 where에 적혔을때랑 결과가 다르다.

*49번*
- (+) : `where A.게시판id = B.게시판id(+)` 는 A에서 `left outer join B on(A.게시판id = B.게시판id)` 와 같은것
	- `where A.게시판id = B.게시판id(+) and b.삭제여부(+) ='N'` 는 `from A left outer join ( A.게시판id = B.게시판id and B.삭제여부 = 'N')`
- 3번이 안되는 이유 : 결과적으로 비슷할지 모르지만, `left outer join`을 하면 최소한 왼쪽 테이블의 모든 행은 결과에 포함되어야하지만, `where B.삭제여부 = 'N'` 조건을 주게되면 결과에서 빠져버리는 왼쪽 테이블의 행이 있을 수 있다.
- 4번이 안되는 이유 : 문제에서 제시된 쿼리는 A.사용여부='Y'가 아닌건 거르기로 되어있는데 4번의 쿼리는 거르지 않고 출력한다.

53번
- Set operator 집합 연산자
	- union : 합집합 (union all 은 중복도 포함하는 합집합)
	- intersect : 교집합
	- except(어떤 db는 Minus라고) : 차집합

54번
- union 연산자를 사용한 sql은 각각의 집합에 gorup by 절을 사용할 수 있다.

*55번*
- 

57번
- `group by grade, job`이랑 `group by job, grade`는 같은 결과를 산출한다.

58번
- 아래의 두 함수는 같은 결과를 출력
	- `round(ratio_to_report(급여) over (partition by 부서코드),2)` 
	- `round(급여/부서급여합,2) ... from ( .. sum(급여) over (partition by 부서코드) 부서급여 합 ..`
- 누적합
	- `sum(급여) over (partion by 부서코드 order by 사원번호) 부서급여합`
	- 한 사원에 대해서 데이터를 볼 때, 해당 사원의 `부서급여합`은 부서 전체가 아니라 사원번호로 순서지었을 때 해당 사원의 순서까지의 누적 합이 된다.

62번
- connect by 절에 작성된 조건은 where절에 작성된 조건과 달리 부모에는 적용이 되지 않는다. 

63번
- where 절은 모든 전개를 진행한 이후 필터 조건으로서 조건을 만족하는 데이터만을 추출하는 데 활용된다.

64번
- 