# 개념
## 데이터 모델링의 이해
2,3,3,2,3 / 2,4,4,2,3 / 1,1,1,2,3 / 2,1,4,3,4 / 2,2,2,3,4 / 4,4,2,2,3/ 3,2,1,3,2 / 3,4,4,3,3 / 1,2,2,1,1 / 3,1,2,1,4

속성 : 
- 기본 속성 : 엔터티가 본래부터 가지고 있어야 하는 속성.
- 설계 속성 : 시스템 설계시에 필요하다고 판단되어 도출된 속성.
- 파생 속성 :  다른 속성으로부터 계산되거나 특정 규칙에 따라 변형되어 만들어진 속성.

도메인 :
- 속성이 가질 수 있는 값의 범위
	- 예시) 다섯자리 숫자, 1 부터 100 까지의 숫자 등

엔터티의 유형 (발생 시점에 따른 분류): 
- 기본 엔터티
- 중심 엔터티
- 행위 엔터티

순수 관계 연산자 :
- select
- project
- join
- divide

배치(batch) 작업 : 

self-join : 
running total을 구할때 사용



# 문제
11번
- 테이블에 `''`을 입력하면 null이 입력된다
- `varchar2`자료형임에도 모두 숫자인경우 `where col1 = 1`처럼 숫자로 질의를 해도 오류가 나지 않는다.

12번
- LTRIM RTRIM 모두공백을 포함하지 않음

13번
- `to_date('201501', 'YYYYMM')`은 2015년 01월 01일 00시 00분이 된다.

14번
- group by 절에서는 select 절과 같이 alias 명을 사용할 수 없다.
- 집계 함수는 null 값을 제외하여 수행한다.

17번
- `case when loc = 'New York' then 'east' else 'etc' end`
- `case loc when 'New York' then 'east' else 'etc' end`
- `decode(loc, 'New York', 'east', 'etc')`
- 위는 모두 같은 결과를 출력한다.

18번
- sql server에서 `isnull`은 오라클의 `nvl`과 같은 함수

20번
- `Nullif()`함수는 컬럼의 값이 어떤것과 같으면 null로 표기한다

22번
- `_`는 글자수를 지정

28번
- `order by (case when id = '999' then 0 else id end)`
- 여기서 0은 순서가 된다.

29번
- 원래는 select절에 없는 컬럼을 가지고 order by를 할 수 없지만, oracle은 가능하다.(행기반 데이터베이스여서)
- 그러나 group by 절을 사용한다면 반드시 group by 절에 포함된 컬럼만 사용 가능하다.

35번
- dbms 옵티마이저는 조인을 2개의 테이블씩 처리한다.
- 일반적으로 조인은 pk와 fk의 값의 연관성에 의해 성립
- equi join 은 테이블 간의 칼럼 값들이 정확하게 일치하는 경우에 사용되는 방법, '=' 연산자에 의해서만 수행된다
- >, <, >=, <= 과 같은 부등식은 non equi join

37번
- 순수 관계 연산자

*38번*
- 1번이 오답인 이유 : where의 연관 서브 쿼리 결과를 예측해보면 고객id가 001에 해당하는 모든 컨텐츠id가 출력된다. 그래서 하나라도 비선호컨텐츠를 추가한 회원은 언제나 결과가 t가 되기 때문에 어떤 추천도 받지 못한다.
- 2번이 오답인 이유 :
	- 일단 비선호컨텐츠에 있는 컨텐츠id를 거르려면 `and d.컨텐츠id is null`이어야 한다.

*41번*
- 1번이 오답인 이유 : `B.사용시간대 <= C.시작시간대 and B.사용시간대 >= C.시작시간대`는 B 사용시간대가 C의 구간을 완전히 포함해야한다.
- 2번이 오답인 이유 : `from 고객 A inner join 시간대별사용량 B inner join 시간대구간 C` 과 같은 문법은 없다.

*44번*
- 2번이 아닌 이유 : `left outer join 단말기 B on (A.고객번호 in (11000,12000) and A.단말기id = B.단말기id)` 
	- left outer join이기 때문에 행 수는 고객 테이블과 일치하는게 맞다.
	- 그리고 join on 안에 조건이 적혀있기 때문에 join 이전에 적용되기 때문에 where에 적혔을때랑 결과가 다르다.

*49번*
- (+) : `where A.게시판id = B.게시판id(+)` 는 A에서 `left outer join B on(A.게시판id = B.게시판id)` 와 같은것
	- `where A.게시판id = B.게시판id(+) and b.삭제여부(+) ='N'` 는 `from A left outer join ( A.게시판id = B.게시판id and B.삭제여부 = 'N')`
- 3번이 안되는 이유 : 결과적으로 비슷할지 모르지만, `left outer join`을 하면 최소한 왼쪽 테이블의 모든 행은 결과에 포함되어야하지만, `where B.삭제여부 = 'N'` 조건을 주게되면 결과에서 빠져버리는 왼쪽 테이블의 행이 있을 수 있다.
- 4번이 안되는 이유 : 문제에서 제시된 쿼리는 A.사용여부='Y'가 아닌건 거르기로 되어있는데 4번의 쿼리는 거르지 않고 출력한다.

53번
- Set operator 집합 연산자
	- union : 합집합 (union all 은 중복도 포함하는 합집합)
	- intersect : 교집합
	- except(어떤 db는 Minus라고) : 차집합

54번
- union 연산자를 사용한 sql은 각각의 집합에 gorup by 절을 사용할 수 있다.

*55번*
- 

57번
- `group by grade, job`이랑 `group by job, grade`는 같은 결과를 산출한다.

58번
- 아래의 두 함수는 같은 결과를 출력
	- `round(ratio_to_report(급여) over (partition by 부서코드),2)` 
	- `round(급여/부서급여합,2) ... from ( .. sum(급여) over (partition by 부서코드) 부서급여 합 ..`
- 누적합
	- `sum(급여) over (partion by 부서코드 order by 사원번호) 부서급여합`
	- 한 사원에 대해서 데이터를 볼 때, 해당 사원의 `부서급여합`은 부서 전체가 아니라 사원번호로 순서지었을 때 해당 사원의 순서까지의 누적 합이 된다.

62번
- connect by 절에 작성된 조건은 where절에 작성된 조건과 달리 부모에는 적용이 되지 않는다. 

63번
- where 절은 모든 전개를 진행한 이후 필터 조건으로서 조건을 만족하는 데이터만을 추출하는 데 활용된다.

64번
- 인간 관점에서 상위부서(루트)-하위부서(자식) 이렇게 생각하기 쉽지만, 프로그램 관점에서는 무조건 `start with`로 선택된 노드가 루트. 그리고 `connect by`로 선택되는 노드들이 그 자식들이다.

65번
- join, inner join, natural join 모두 같은 것이다.

66번
- 2번이 안되는 이유 
- `from 일자별매출 a join 일자별 매출 b on (a.일자>=b.일자)`는 다음과 같다.
(a.일자, b.일자, 매출액)
1일, 1일, 1000
2일, 1일, 1000
2일, 2일, 1000
3일, 1일, 1000
3일, 2일, 1000
3일, 3일, 1000
- 여기서 `group by b.일자`로  `sum(b.매출액)` 을 구하면?
(b.일자, sum)
1일, 3000
2일, 2000
3일, 1000
- `b.일자`를 기준으로 그룹핑을 하면 b.1일은 a의(1일,2일,3일) 을 가지고 있기 때문에 3000이 된다.
- `group by a.일자`로 하면?
1일, 1000
2일, 2000
3일, 3000

67번
- `distinct`함수는 from, where, group by, having 등으로 완성된 테이블에서 마지막으로 

68번
- 서브쿼리는 단일 행, 또는 복수 행 비교연산자와 함께 사용할 수 있다.
- 서브쿼리는 select절, from절, having절, order by절 등에서 사용이 가능하다.
- 다중 칼럼 서브쿼리는 서브쿼리의 결과로 여러 개의 칼럼이 반환되어 메인쿼리의 조건과 동시에 비교되는 것을 의미한다.

*69번*
*71번*

72번
- 비연관 서브쿼리는 주로 메인쿼리에 값을 제공하기 위한 목적으로 사용된다.
- 메인쿼리의 결과를 가지고 서브쿼리에서 조건이 만족하는지 확인할 수도 있고 반대일수도 있다.

74번
- 나는 `select 상품id, 평가항목id, max(평가회차)` 테이블을 만들어서 다시 조인하는 방법으로 풀었지만 다른 풀이법들도 있다.
1. 윈도우 함수
```sql
select 상품id, 평가항목id, 평가회차, 평가등급, 평가일자
from (
    select 상품id, 평가항목id, 평가회차, 평가등급, 평가일자,
           row_number() over (partition by 상품id, 평가항목id 
                             order by 평가회차 desc) as rn
    from 평가결과
) ranked
where rn = 1
```
2. exists
```sql
select c1.상품id, c1.평가항목id, c1.평가회차, c1.평가등급, c1.평가일자
from 평가결과 c1
where not exists (
    select 1 from 평가결과 c2 
    where c2.상품id = c1.상품id 
    and c2.평가항목id = c1.평가항목id 
    and c2.평가회차 > c1.평가회차
)
```

*78번*

82번
- `ROLLUP(A, B)` = `ROLLUP((A), (B))` = a+b, a, 전체
- `ROLLUP((A,B))` = a+b, 전체

84번
- partition by 절과 group by 절은 의미적으로 유사하다.
- partition by 절이 없으면 전체 집합을 하나의 partition으로 정의한 것과 동일하다.

92번
- `grant select, update on A_User.TB_A to B_User` 을 통해 B_User에게 권한을 부여

101번
- 트랜잭션의 특성
	- 원자성 : 트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되든지 아니면 전혀 실행되지 않은 상태로 남아 이썽야 한다.
	- 일관성 : 트랜잭션이 실행 되기 전의 데이터베이스 내용이 잘못되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터에비스의 내용에 잘못이 있으면 안된다.
	- 고립성 : 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안 된다.
	- 영속성 : 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다.

116번
- 숫자 `20190302`는 자동으로 날짜로 형변환되지 않는다.

